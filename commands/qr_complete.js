/*
QR Code Generator and Scanner Command
Supports both generating QR codes from text and scanning QR codes from images
*/

const QRCode = require('qrcode');
const jimp = require('jimp');
const jsQR = require('jsqr');
const { downloadMediaMessage } = require('@whiskeysockets/baileys');
const fs = require('fs');
const path = require('path');

async function qrCommand(sock, chatId, message) {
    try {
        const text = message.message?.conversation || message.message?.extendedTextMessage?.text;
        const args = text.split(' ').slice(1);
        const command = args[0]?.toLowerCase();

        if (!command || (command !== 'generate' && command !== 'scan')) {
            const helpText = `*QR Code Generator & Scanner* üì±

*Commands:*
‚Ä¢ \`.qr generate <text>\` - Generate QR code from text
‚Ä¢ \`.qr scan\` - Reply to an image to scan QR code

*Examples:*
‚Ä¢ \`.qr generate Hello World\`
‚Ä¢ \`.qr generate https://github.com\`
‚Ä¢ \`.qr scan\` (reply to image containing QR code)

*Features:*
‚úÖ Generate QR codes from any text
‚úÖ Scan QR codes from images
‚úÖ Support for URLs, WiFi, contacts, and more
‚úÖ High-quality PNG output
‚úÖ Fast and reliable

> _Powered by Knight Bot MD_`;

            return await sock.sendMessage(chatId, { text: helpText });
        }

        // QR Code Generator
        if (command === 'generate') {
            const textToEncode = args.slice(1).join(' ').trim();

            if (!textToEncode) {
                return await sock.sendMessage(chatId, {
                    text: "‚ùå Please provide text to generate QR code!\n\nExample: `.qr generate Hello World`"
                });
            }

            try {
                // Show generating message
                await sock.sendMessage(chatId, {
                    text: "üîÑ Generating QR code..."
                }, { quoted: message });

                // Generate QR code
                const qrBuffer = await QRCode.toBuffer(textToEncode, {
                    errorCorrectionLevel: 'M',
                    type: 'png',
                    quality: 0.92,
                    margin: 2,
                    color: {
                        dark: '#000000',
                        light: '#FFFFFF'
                    },
                    width: 512,
                    scale: 8
                });

                // Create temp directory if it doesn't exist
                const tempDir = path.join(__dirname, '../temp');
                if (!fs.existsSync(tempDir)) {
                    fs.mkdirSync(tempDir, { recursive: true });
                }

                const tempFile = path.join(tempDir, `qr_${Date.now()}.png`);
                fs.writeFileSync(tempFile, qrBuffer);

                // Verify file was created
                if (!fs.existsSync(tempFile)) {
                    throw new Error('QR code file creation failed');
                }

                // Send QR code
                await sock.sendMessage(chatId, {
                    image: { url: tempFile },
                    caption: `*QR Code Generated Successfully!* ‚úÖ\n\nüìù *Content:* ${textToEncode}\n\nüìè *Size:* 512x512 pixels\nüíæ *Format:* PNG\n\n> _Generated by Knight Bot MD_`
                }, { quoted: message });

                // Clean up temp file
                setTimeout(() => {
                    try {
                        if (fs.existsSync(tempFile)) {
                            fs.unlinkSync(tempFile);
                        }
                    } catch (cleanupError) {
                        console.error('Cleanup error:', cleanupError);
                    }
                }, 15000);

            } catch (error) {
                console.error('QR Generation Error:', error);
                await sock.sendMessage(chatId, {
                    text: `‚ùå Failed to generate QR code: ${error.message}\n\nPlease try again.`
                });
            }
        }

        // QR Code Scanner
        else if (command === 'scan') {
            const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;

            if (!quotedMessage) {
                return await sock.sendMessage(chatId, {
                    text: "‚ùå Please reply to an image containing a QR code!\n\n*Usage:*\n1. Find a message with an image containing QR code\n2. Reply to that message with `.qr scan`"
                });
            }

            let imageMessage = null;

            // Check different image message types
            if (quotedMessage.imageMessage) {
                imageMessage = quotedMessage.imageMessage;
            } else if (quotedMessage.viewOnceMessage?.message?.imageMessage) {
                imageMessage = quotedMessage.viewOnceMessage.message.imageMessage;
            }

            if (!imageMessage) {
                return await sock.sendMessage(chatId, {
                    text: "‚ùå The replied message doesn't contain an image!\n\nPlease reply to a message that contains an image with a QR code."
                });
            }

            try {
                // Show scanning message
                await sock.sendMessage(chatId, {
                    text: "üîç Scanning QR code from image..."
                }, { quoted: message });

                // Create a proper message object for downloadMediaMessage
                const quotedImageMessage = {
                    message: {
                        imageMessage: imageMessage
                    }
                };

                // Download the image using the correct Baileys method
                const imageBuffer = await downloadMediaMessage(
                    quotedImageMessage,
                    'buffer',
                    {},
                    {}
                );

                if (!imageBuffer || imageBuffer.length === 0) {
                    return await sock.sendMessage(chatId, {
                        text: "‚ùå Failed to download the image! Please try again."
                    });
                }

                // Process image with jimp
                const image = await jimp.read(imageBuffer);
                const { data, width, height } = image.bitmap;

                // Convert RGBA to the format jsQR expects
                const code = jsQR(data, width, height, {
                    inversionAttempts: "dontInvert",
                });

                if (code && code.data) {
                    const qrData = code.data;
                    let responseText = `*QR Code Scanned Successfully!* ‚úÖ\n\n`;
                    responseText += `üìù *Content:* ${qrData}\n\n`;

                    // Detect and categorize content type
                    if (qrData.startsWith('http://') || qrData.startsWith('https://')) {
                        responseText += `üîó *Type:* Website/URL\n`;
                        responseText += `üåê *Link:* ${qrData}\n\n`;
                    } else if (qrData.includes('@') && qrData.includes('.') && !qrData.includes(' ')) {
                        responseText += `üìß *Type:* Email Address\n\n`;
                    } else if (qrData.startsWith('tel:') || qrData.startsWith('+') || /^\d{10,}$/.test(qrData)) {
                        responseText += `üìû *Type:* Phone Number\n\n`;
                    } else if (qrData.toLowerCase().startsWith('wifi:')) {
                        responseText += `üì∂ *Type:* WiFi Configuration\n`;
                        // Parse WiFi QR code format: WIFI:T:WPA;S:NetworkName;P:Password;H:false;;
                        const wifiParts = qrData.match(/WIFI:T:([^;]*);S:([^;]*);P:([^;]*);/i);
                        if (wifiParts) {
                            responseText += `üì∂ *Security:* ${wifiParts[1]}\n`;
                            responseText += `üè† *Network:* ${wifiParts[2]}\n`;
                            responseText += `üîí *Password:* ${wifiParts[3]}\n\n`;
                        }
                    } else if (qrData.startsWith('geo:') || qrData.includes('latitude') || qrData.includes('longitude')) {
                        responseText += `üìç *Type:* Geographic Location\n\n`;
                    } else if (qrData.startsWith('BEGIN:VCARD')) {
                        responseText += `üë§ *Type:* Contact Information (vCard)\n\n`;
                    } else if (qrData.startsWith('SMSTO:')) {
                        responseText += `üí¨ *Type:* SMS Template\n\n`;
                    } else if (qrData.startsWith('mailto:')) {
                        responseText += `üìß *Type:* Email Template\n\n`;
                    } else {
                        responseText += `üìÑ *Type:* Plain Text\n\n`;
                    }

                    responseText += `üìä *Quality:* ${width}x${height} pixels\n`;
                    responseText += `> _Scanned by Knight Bot MD_`;

                    await sock.sendMessage(chatId, { text: responseText });

                } else {
                    await sock.sendMessage(chatId, {
                        text: "‚ùå No QR code found in the image!\n\nüí° *Tips for better scanning:*\n‚Ä¢ Make sure the QR code is clear and visible\n‚Ä¢ Try a higher quality/resolution image\n‚Ä¢ Ensure good lighting in the photo\n‚Ä¢ Make sure the QR code isn't damaged or distorted\n‚Ä¢ Try cropping the image to focus on just the QR code"
                    });
                }

            } catch (error) {
                console.error('QR Scanning Error:', error);
                await sock.sendMessage(chatId, {
                    text: `‚ùå Failed to scan QR code: ${error.message}\n\nPlease try with a clearer image or a different photo.`
                });
            }
        }

    } catch (error) {
        console.error('QR Command Error:', error);
        await sock.sendMessage(chatId, {
            text: "‚ùå An error occurred while processing your request. Please try again or contact support."
        });
    }
}

module.exports = qrCommand;
